{
	// Place your competitiveprogramming workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"DSU": {
		"prefix": "DSU",
		"body": [
			"struct DSU {",
			"    size_t size;",
			"    vector<int> p, sz;",
			"    DSU () { }",
			"    DSU (size_t size): size(size) {",
			"        p.resize (size);",
			"        sz.assign (size, 1);",
			"        iota (p.begin(), p.end(), 0);",
			"    }",
			"    int get (int v) {",
			"        return (v == p[v]) ? v : p[v] = get(p[v]);",
			"    }",
			"    void unite (int u, int v) {",
			"        u = get(u);",
			"        v = get(v);",
			"        if (u == v)",
			"            return;",
			"        if (sz[v] > sz[u])",
			"            swap(u, v);",
			"        p[v] = u;",
			"        sz[u] += sz[v];",
			"    }",
			"};",
			""
		],
		"description": "DSU"
	},

	"Modular integer structure": {
		"prefix": "Modular",
		"body": [
			"const long long mod = 1000000007;",
			"",
			"struct Modular {",
			"    long long val;",
			"    ",
			"    Modular (long long x) {",
			"        if (x < 0) {",
			"            x %= mod;",
			"            x += mod;",
			"        }",
			"        if (x >= mod) {",
			"            x %= mod;",
			"        }",
			"        val = x;",
			"    }",
			"    Modular (): val(0) { }",
			"",
			"    friend Modular operator+ (const Modular lhs, const Modular rhs) {",
			"        return (lhs.val + rhs.val >= mod) ? lhs.val + rhs.val - mod : lhs.val + rhs.val;",
			"    }",
			"",
			"    Modular& operator+= (const Modular rhs) {",
			"        return *this = *this + rhs;",
			"    }",
			"    friend Modular operator- (const Modular lhs, const Modular rhs) {",
			"        return (lhs.val - rhs.val < 0) ? lhs.val - rhs.val + mod : lhs.val - rhs.val;",
			"    }",
			"",
			"    Modular& operator-= (const Modular rhs) {",
			"        return *this = *this - rhs;",
			"    }",
			"    friend Modular operator- (const Modular rhs) {",
			"        return mod - rhs;",
			"    }",
			"",
			"    friend Modular operator* (const Modular lhs, const Modular rhs) {",
			"        return (lhs.val * rhs.val) % mod;",
			"    }",
			"    Modular& operator*= (const Modular rhs) {",
			"        return *this = *this * rhs;",
			"    }",
			"",
			"    friend bool operator== (const Modular lhs, const Modular rhs) {",
			"        return lhs.val == rhs.val;",
			"    }",
			"    friend bool operator!= (const Modular lhs, const Modular rhs) {",
			"        return lhs.val != rhs.val;",
			"    }",
			"    friend bool operator< (const Modular lhs, const Modular rhs) {",
			"        return lhs.val < rhs.val;",
			"    }",
			"    friend bool operator<= (const Modular lhs, const Modular rhs) {",
			"        return lhs.val <= rhs.val;",
			"    }",
			"    friend bool operator> (const Modular lhs, const Modular rhs) {",
			"        return lhs.val > rhs.val;",
			"    }",
			"    friend bool operator>= (const Modular lhs, const Modular rhs) {",
			"        return lhs.val >= rhs.val;",
			"    }",
			"",
			"    friend Modular operator^ (Modular lhs, Modular rhs) {",
			"        Modular res = 1;",
			"        while (rhs != 0) {",
			"            if (rhs.val & 1)",
			"                res *= lhs;",
			"            lhs *= lhs;",
			"            rhs.val >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"    Modular& operator^= (const Modular rhs) {",
			"        return *this = (*this ^ rhs);",
			"    }",
			"",
			"    friend Modular operator* (const Modular rhs) {",
			"        return rhs ^ (mod - 2);",
			"    }",
			"",
			"    friend Modular operator/ (const Modular lhs, const Modular rhs) {",
			"        return lhs * (*rhs);",
			"    }",
			"    Modular& operator/= (const Modular rhs) {",
			"        return *this = *this / rhs;",
			"    }",
			"",
			"    friend ostream& operator<< (ostream& out, const Modular rhs) {",
			"        out << rhs.val;",
			"        return out;",
			"    }",
			"    friend istream& operator>> (istream& in, Modular &rhs) {",
			"        in >> rhs.val;",
			"        if (rhs.val < 0) {",
			"            rhs.val %= mod;",
			"            rhs.val += mod;",
			"        }",
			"        if (rhs.val >= mod) {",
			"            rhs.val %= mod;",
			"        }",
			"        return in;",
			"    }",
			"};",
			""
		],
		"description": "Modular integer structure"
	},

	"Segment Tree": {
		"prefix": "SegmentTree",
		"body": [
			"struct MaxMerger {",
			"    void operator()(int& res, int& a, int& b) const {",
			"        res = max(a, b);",
			"    }",
			"};",
			"template <",
			"    typename T,",
			"    typename Merge = MaxMerger",
			">",
			"struct SegmentTree {",
			"    int n;",
			"    T neutral;",
			"    Merge merge;",
			"    vector<T> tr;",
			"    SegmentTree (int n, T neutral): n(n), neutral(neutral) {",
			"        tr.assign (4 * n + 5, neutral);",
			"        merge = Merge();",
			"    }",
			"    T _get (int node, int l, int r, int ql, int qr) {",
			"        if (l >= ql && r <= qr) {",
			"            return tr[node];",
			"        }",
			"        if (l > qr || r < ql) {",
			"            return neutral;",
			"        }",
			"        int m = (l + r) / 2;",
			"        T a = _get (node * 2 + 1, l, m, ql, qr),",
			"          b = _get (node * 2 + 2, m + 1, r, ql, qr),",
			"          cur;",
			"        merge (cur, a, b);",
			"        return cur;",
			"    }",
			"    void _upd (int node, int l, int r, int ql, int qr, T val) {",
			"        if (ql == l && qr == r) {",
			"            tr[node] = val;",
			"            return;",
			"        }",
			"        if (l > qr || r < ql) {",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        _upd (node * 2 + 1, l, m, ql, qr, val);",
			"        _upd (node * 2 + 2, m + 1, r, ql, qr, val);",
			"        merge (tr[node], tr[node * 2 + 1], tr[node * 2 + 2]);",
			"    }",
			"    int _gr(int node, int l, int r, int ql, int qr, int val) {",
			"        if (l > qr || r < ql) ",
			"            return Inf;",
			"        if (ql <= l && r <= qr) {",
			"            if (tr[node] < val) ",
			"                return Inf;",
			"            while (r - l > 0) {",
			"                int mid = (r + l) / 2;",
			"                if (tr[2 * node + 1] >= val) {",
			"                    node = 2 * node + 1;",
			"                    r = mid;",
			"                }",
			"                else {",
			"                    node = 2 * node + 2;",
			"                    l = mid + 1;",
			"                }",
			"            }",
			"            return l;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        return min( _gr(2 * node + 1, l, mid, ql, qr, val),",
			"                    _gr(2 * node + 2, mid + 1, r, ql, qr, val));",
			"    }",
			"    T get (int l, int r) {",
			"        return _get (0, 0, n - 1, l, r);",
			"    }",
			"    void update (int idx, T val) {",
			"        _upd (0, 0, n - 1, idx, idx, val);",
			"    }",
			"    /**",
			"     * @brief Find nearest to the right of l greater than val",
			"     * ",
			"     * @param Merge Must be MaxMerger",
			"     * @param l Position",
			"     * @param val Value",
			"     * @return Position of element >= val ",
			"     */",
			"    int greater_r (int l, int val) {",
			"        int ans = _gr(0, 0, n - 1, l, n - 1, val + 1);",
			"        return ans == Inf ? -1 : ans;",
			"    }",
			"};"
		],
		"description": "Segment Tree"
	},

	"Lazy Segment Tree": {
		"prefix": "LazySegmentTree",
		"body": [
			"struct MaxMerger {",
			"    void operator()(int& res, int& a, int& b) const {",
			"        res = max(a, b);",
			"    }",
			"};",
			"",
			"template <",
			"    typename T,",
			"    typename Merge = MaxMerger",
			">",
			"struct LazySegmentTree {",
			"    int n;",
			"    T neutral;",
			"    Merge merge;",
			"    vector<T> tr, lz;",
			"    vector<bool>  clz;",
			"    LazySegmentTree (int n, T neutral): n(n), neutral(neutral) {",
			"        tr.assign (4 * n + 5, neutral);",
			"        lz.assign (4 * n + 5, 0);",
			"        clz.assign (4 * n + 5, 0);",
			"        merge = Merge();",
			"    }",
			"    void push (int node, int l, int r) {",
			"        if (!clz[node])",
			"            return;",
			"        if (l != r) {",
			"            clz[node * 2 + 1] = 1;",
			"            clz[node * 2 + 2] = 1;",
			"            lz[node * 2 + 1] = lz[node];",
			"            lz[node * 2 + 2] = lz[node];",
			"        }",
			"        tr[node] = lz[node] * (r - l + 1);",
			"        lz[node] = 0;",
			"        clz[node] = 0;",
			"    }",
			"    T _get (int node, int l, int r, int ql, int qr) {",
			"        push (node, l, r);",
			"        if (l >= ql && r <= qr) {",
			"            return tr[node];",
			"        }",
			"        if (l > qr || r < ql) {",
			"            return neutral;",
			"        }",
			"        int m = (l + r) / 2;",
			"        T a = _get (node * 2 + 1, l, m, ql, qr),",
			"          b = _get (node * 2 + 2, m + 1, r, ql, qr),",
			"          cur;",
			"        merge (cur, a, b);",
			"        return cur;",
			"    }",
			"    void _upd (int node, int l, int r, int ql, int qr, T val) {",
			"        push (node, l, r);",
			"        if (l >= ql && r <= qr) {",
			"            clz[node] = 1;",
			"            lz[node] = val;",
			"            push (node, l, r);",
			"            return;",
			"        }",
			"        if (l > qr || r < ql) {",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        _upd (node * 2 + 1, l, m, ql, qr, val);",
			"        _upd (node * 2 + 2, m + 1, r, ql, qr, val);",
			"        merge (tr[node], tr[node * 2 + 1], tr[node * 2 + 2]);",
			"    }",
			"    int _gr(int node, int l, int r, int ql, int qr, int val) {",
			"        if (l > qr || r < ql) ",
			"            return Inf;",
			"        if (ql <= l && r <= qr) {",
			"            if (tr[node] < val) ",
			"                return Inf;",
			"            while (r - l > 0) {",
			"                int mid = (r + l) / 2;",
			"                if (tr[2 * node + 1] >= val) {",
			"                    node = 2 * node + 1;",
			"                    r = mid;",
			"                }",
			"                else {",
			"                    node = 2 * node + 2;",
			"                    l = mid + 1;",
			"                }",
			"            }",
			"            return l;",
			"        }",
			"        int mid = (l + r) / 2;",
			"        return min( _gr(2 * node + 1, l, mid, ql, qr, val),",
			"                    _gr(2 * node + 2, mid + 1, r, ql, qr, val));",
			"    }",
			"    T get (int l, int r) {",
			"        return _get (0, 0, n - 1, l, r);",
			"    }",
			"    void update (int l, int r, T val) {",
			"        _upd (0, 0, n - 1, l, r, val);",
			"    }",
			"    void update (int idx, T val) {",
			"        _upd (0, 0, n - 1, idx, idx, val);",
			"    }",
			"    /**",
			"     * @brief Find nearest to the right of l greater than val",
			"     * ",
			"     * @param Merge Must be MaxMerger",
			"     * @param l Position",
			"     * @param val Value",
			"     * @return Position of element >= val ",
			"     */",
			"    int greater_r (int l, int val) {",
			"        int ans = _gr(0, 0, n - 1, l, n - 1, val + 1);",
			"        return ans == Inf ? -1 : ans;",
			"    }",
			"};"
		],
		"description": "Lazy Segment Tree"
	},

	"Sparse Table": {
		"prefix": "Sparse",
		"body": [
			"struct SPMaxMerger {",
			"    int operator()(int a, int b) const {",
			"        return max(a, b);",
			"    }",
			"};",
			"",
			"template <",
			"    typename T,",
			"    typename SPMerge = SPMaxMerger",
			">",
			"struct SparseTable {",
			"    size_t size, k;",
			"    vector<vector<T>> sparse;",
			"    SPMerge merge;",
			"    SparseTable (): merge (SPMerge()) { }",
			"    SparseTable (size_t size): merge (SPMerge()), size (size), k (__lg (size) + 1) {",
			"        sparse.assign (k, vector<T> (size));",
			"    } ",
			"    SparseTable (vector<T> v): merge (SPMerge()), size (v.size()), k (__lg (size) + 1) {",
			"        sparse.assign (k, vector<T> (size, 0));  ",
			"        sparse[0] = v;  ",
			"        for (int l = 1; l < k; ++l)",
			"            for (int i = 0; i + (1 << l) <= size; ++i)",
			"                sparse[l][i] = merge (sparse[l - 1][i], sparse[l - 1][i + (1 << (l - 1))]);",
			"    }",
			"    T get (int l, int r) {",
			"        int lg = __lg (r - l + 1);",
			"        return merge (sparse[lg][l], sparse[lg][r - (1 << lg) + 1]);",
			"    }",
			"};",
			""
		],
		"description": "Sparse Table"
	},

	"String Comparator": {
		"prefix": "StringComparator",
		"body": [
			"template <",
			"    int modA = 1000000009,",
			"    int modB = 1000000123",
			">",
			"struct StringComparator {",
			"    struct HashInt {",
			"        long long a, b;",
			"        HashInt (): a(0), b(0) { }",
			"        HashInt (long long x): a(x), b(x) { }",
			"        HashInt (long long a, long long b): a(a), b(b) { }",
			"        friend HashInt operator+ (const HashInt lhs, const HashInt rhs) {",
			"            return HashInt ((lhs.a + rhs.a) % modA, (lhs.b + rhs.b) % modB);",
			"        }",
			"        friend HashInt operator- (const HashInt lhs, const HashInt rhs) {",
			"            return HashInt ((lhs.a - rhs.a + modA) % modA, (lhs.b - rhs.b + modB) % modB);",
			"        }",
			"        friend HashInt operator* (const HashInt lhs, const long long x) {",
			"            return HashInt ((lhs.a * x) % modA, (lhs.b * x) % modB);",
			"        }",
			"        friend HashInt operator* (const HashInt lhs, const HashInt rhs) {",
			"            return HashInt ((lhs.a * rhs.a) % modA, (lhs.b * rhs.b) % modB);",
			"        }",
			"        friend bool operator== (const HashInt lhs, const HashInt rhs) {",
			"            return lhs.a == rhs.a && lhs.b == rhs.b;",
			"        }",
			"        explicit operator long long () const {",
			"            return a * modB + b + 1;",
			"        }",
			"    };",
			"    long long p = 239;",
			"    string s;",
			"    vector<HashInt> h, pows;",
			"    StringComparator (string s): s(s) {",
			"        h.assign(s.size() + 1, 0);",
			"        for (int i = 0; i < s.size(); ++i)",
			"            h[i + 1] = h[i] * p + s[i];",
			"        pows.emplace_back(HashInt(1));",
			"        for (int i = 0; i <= s.size(); ++i)",
			"            pows.push_back(pows.back() * p);",
			"    }",
			"    /**",
			"     * @brief IMPORTANT! Second arg is length ",
			"     */",
			"    HashInt substr (int idx, int len) const {",
			"        return h[idx + len] - h[idx] * pows[len];",
			"    }",
			"    int lcp (int i, int j) {",
			"        int l = 0, r = s.size() - max(i, j);",
			"        while (r - l > 0) {",
			"            int m = (l + r + 1) / 2;",
			"            if (substr(i, m) == substr(j, m))",
			"                l = m;",
			"            else",
			"                r = m - 1;",
			"        }",
			"        return l;",
			"    }",
			"    int cmp (int a, int b) {",
			"        int len = s.size() - max(a, b), l = lcp(a, b);",
			"        return l < len ? (int)s[a + l] - s[b + l] : b - a;",
			"    }",
			"    bool operator() (int i, int j) { ",
			"        return cmp(i, j) < 0; ",
			"    }",
			"};"
		],
		"description": "String Comparator"
	},

	"Fenwick Tree with Range Updates": {
		"prefix": "FenwickRanges",
		"body": [
			"template <",
			"    typename T",
			">",
			"struct FenwickRange {",
			"    vector <T> tr;",
			"    FenwickRange () { }",
			"    FenwickRange (size_t size) {",
			"        tr.assign(size + 2, 0);",
			"    }",
			"    void update (int idx, T delta) {",
			"        for (++idx; idx < tr.size(); idx += idx & -idx)",
			"            tr[idx] += delta;",
			"    }",
			"    void update (int l, int r, T delta) {",
			"        update(l, delta);",
			"        update(r + 1, -delta);",
			"    }",
			"    T get (long long r) {",
			"        if (r <= 0)",
			"            return 0;",
			"        T res = 0;",
			"        for (++r; r > 0; r -= r & -r)",
			"            res += tr[r];",
			"        return res;",
			"    }",
			"};",
			"",
			"template <",
			"    typename T",
			">",
			"struct FenwickRanges {",
			"    FenwickRange<T> G1, G2;",
			"    FenwickRanges (size_t size) {",
			"        G1 = FenwickRange<T>(size);",
			"        G2 = FenwickRange<T>(size);",
			"    }",
			"    void update (int l, int r, int delta) {",
			"        G1.update(l, r, delta);",
			"        G2.update(l, delta * (l - 1));",
			"        G2.update(r + 1, -delta * r);",
			"    }",
			"    T get (int r) {",
			"        return G1.get(r) * r - G2.get(r);",
			"    }",
			"    T get (int l, int r) {",
			"        return get(r) - get(l - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree with Range Updates"
	},

	"Fenwick Tree": {
		"prefix": "Fenwick",
		"body": [
			"template <",
			"    typename T",
			">",
			"struct Fenwick {",
			"    vector <T> tr;",
			"    Fenwick (size_t size) {",
			"        tr.assign(size, 0);",
			"    }",
			"    void update (size_t idx, T delta) {",
			"        for (; idx < tr.size(); idx |= idx + 1)",
			"            tr[idx] += delta;",
			"    }",
			"    T get (long long r) {",
			"        if (r < 0)",
			"            return 0;",
			"        T res = 0;",
			"        for (++r; r > 0; r &= r - 1)",
			"            res += tr[r - 1];",
			"        return res;",
			"    }",
			"    T get (long long l, long long r) {",
			"        return get (r) - get(l - 1);",
			"    }",
			"};"
		],
		"description": "Fenwick Tree"
	}
}